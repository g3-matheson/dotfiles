#### TODO-Tree-like comments:
TODO: something to do
HACK: hacky code
WARN: warning
PERF: performance issue
NOTE: note something
FIX: fix this
BUG: known bug

---

------ GIT CONFLICT KEYS
co            -> choose ours
ct            -> choose theirs
cb            -> choose both
c0            -> choose none
]x            -> move to previous conflict
[x            -> move to next conflict


#### bash nvim commands:
nvim -r       -> list available swap (recovery) files
nvim -r [file]-> open buffer of [file] to recover
fg            -> re-open suspended nvim (Ctrl-Z)

#### nvim commands
ZZ [or] !wq   -> save and quit
:e            -> restore to saved version
:q!           -> quit without saving
:w!           -> overwrite existing file
:w (newfile)  -> save with new filename

C, D, Y       -> same as c$, d$, y$ (not cc,dd,yy)
D             -> same as d$
R             -> overwrite
~             -> change case and move to next letter
X             -> delete to the left of the cursor
xp            -> transpose 2 chars
[n]i/a [text] -> repeats [text] [n] times
[n] cl        -> use instead of [n] s since this is bound to seach

----- SCREEN MOVEMENT

Scrolling the screen:
^F            -> Scroll forward a screen
^D            -> Scroll forward half a screen
^B            -> Scroll back a screen
^U            -> Scroll back half a screen

Reposition the screen:
z enter       -> Move current line to top of screen
z .           -> Move current line to center of screen
z -           -> Move current line to bottom of screen
Can also use these with numbers:
[n] z enter   -> Move line [n] to top of screen

Movement within the screen:
M             -> moves to middle of the screen
H/L           -> moves to top/bottom of screen (but remapped by lazyvim to buffer swap)

-------- TEXT MOVEMENT
Line Movements:
+ [or] enter  -> move to first non-blank char of next line
-             -> move to first non-blank char of previous line
^ [or] _      -> move to first non-blank char of current line
[n] |         -> move to [n]th column of current line or last if n > max
[n]G          -> move to line [n]

Text Block Movements:
( [or] )      -> move to beginning of current/next sentence
{ [or] }      -> move to beginning of current/next paragraph
[[ [or] ]]    -> move to beginning of current/next section

To find the end of a sentence, vim looks for punctuation: ? . or !
  -> the end of the sentence is when punctuation is followed by at least 2 spaces
     or last non-blank char on a line, or \n and a space (or 2 \n)

A paragraph is text up until the next blank line

------ SEARCHING
c[or]d ?[or]/ [word]   -> delete/change found word
f/F [char]             -> move to next/last occurrence of char
t/T [char]             -> move to char before next / after previous occurrence of char
;/,                    -> repeat find command in same/opposite direction

------ REGISTERS
"[n]p         -> paste n-th register (up to 9, 1 = last, 2 = second-last...)
"[char][n]yy   -> yank [n] lines into register [char]
"[char]p/P    -> paste contents of saved register [char]
can also do things like "[char]dw / dd / d} etc.
** use the capitalized version of [char] to APPEND to that register.

------- BOOKMARKS
m[char]       -> mark current pos with [char]
'[char]       -> move to start of line marked by [char]
''[char]      -> return to start of line of previous mark or context after a move
`[char]       -> move to exact location marked by [char]
``[char]      -> return to exact position of previous mark or context after a move


