#### TODO-Tree-like comments:
TODO: something to do
HACK: hacky code
WARN: warning
PERF: performance issue
NOTE: note something
FIX: fix this
BUG: known bug

--- NEO TREE
Shift-P       -> toggle Previewing files
Backspace     -> go up a level
.             -> make this folder root

--- WINDOWS
[n]^W <[or]>  -> make current window [n] columns thinner [or] wider

------ GIT CONFLICT KEYS
co            -> choose ours
ct            -> choose theirs
cb            -> choose both
c0            -> choose none
]x            -> move to previous conflict
[x            -> move to next conflict

#### bash nvim commands:
nvim -r       -> list available swap (recovery) files
nvim -r [file]-> open buffer of [file] to recover
fg            -> re-open suspended nvim (Ctrl-Z)

------- SAVING/LOADING/QUITTING
ZZ [or] !wq   -> save and quit
:e            -> restore to saved version
:q!           -> quit without saving
:w!           -> overwrite existing file
:w (newfile)  -> save with new filename

------- EDITING
C, D, Y       -> same as c$, d$, y$ (not cc,dd,yy)
D             -> same as d$
R             -> overwrite
~             -> change case and move to next letter
X             -> delete to the left of the cursor
xp            -> transpose 2 chars
[n]i/a [text] -> repeats [text] [n] times
[n] cl        -> use instead of [n] s since this is bound to seach

----- SCREEN MOVEMENT
Scrolling the screen:
^F            -> Scroll forward a screen
^D            -> Scroll forward half a screen
^B            -> Scroll back a screen
^U            -> Scroll back half a screen

Reposition the screen:
z enter       -> Move current line to top of screen
z .           -> Move current line to center of screen
z -           -> Move current line to bottom of screen
Can also use these with numbers:
[n] z enter   -> Move line [n] to top of screen

Movement within the screen:
M             -> moves to middle of the screen
H/L           -> moves to top/bottom of screen (but remapped by lazyvim to buffer swap)

-------- TEXT MOVEMENT
Word movements:
#             -> previous instance of current word
*             -> next instance of current word

Line Movements:
+ [or] enter  -> move to first non-blank char of next line
-             -> move to first non-blank char of previous line
^ [or] _      -> move to first non-blank char of current line
[n] |         -> move to [n]th column of current line or last if n > max
[n]G          -> move to line [n]

Text Block Movements:
( [or] )      -> move to beginning of current/next sentence
{ [or] }      -> move to beginning of current/next paragraph
[[ [or] ]]    -> move to beginning of current/next section

To find the end of a sentence, vim looks for punctuation: ? . or !
  -> the end of the sentence is when punctuation is followed by at least 2 spaces
     or last non-blank char on a line, or \n and a space (or 2 \n)

A paragraph is text up until the next blank line

------ SEARCHING
c[or]d ?[or]/ [word]   -> delete/change found word
f/F [char]             -> move to next/last occurrence of char
t/T [char]             -> move to char before next / after previous occurrence of char
;/,                    -> repeat find command in same/opposite direction

------ REGISTERS
"[n]p         -> paste n-th register (up to 9, 1 = last, 2 = second-last...)
"[char][n]yy   -> yank [n] lines into register [char]
"[char]p/P    -> paste contents of saved register [char]
can also do things like "[char]dw / dd / d} etc.
** use the capitalized version of [char] to APPEND to that register.

------- BOOKMARKS
m[char]       -> mark current pos with [char]
'[char]       -> move to start of line marked by [char]
''[char]      -> return to start of line of previous mark or context after a move
`[char]       -> move to exact location marked by [char]
``[char]      -> return to exact position of previous mark or context after a move

-------------------------
------ EX EDITOR
ex [file]     -> enter ex mode on [file]
:[command]    -> ex commands in nvim

:w            -> write buffer but don't exit
:w [filename] -> write buffer to new file
:q            -> quit
:wq           -> write buffer and quit, add ! to circumvent warnings
:x            -> write buffer only if modified and quit

---- Global Search
:g/[pattern]    -> move to last occurence of [pattern]
:g/[pattern]/p  -> find and display all lines containing [pattern] one at a time
:g!/[pattern]/nu -> find and display all lines that do NOT contain [pattern] with line numbers
:60,100g/...     -> find lines between 60,100

---- Combining commands
:1,3d | s/their/their        -> delete lines 1-3, then make substitution on current line (now 4)
:1,5 m 10 | g/pattern/nu     -> move lines 1-5 after line 10, display all lines (with numbers) containing pattern

---- Saving part of a file
:230,$w [filename]      -> save from line 230-end to [filename]
:.,600w [filename]      -> save from line current-600 in [filename]

---- Append to a file
:230,$w >> [filename]

--- copy from other file into open one
:[n]r [filename]        -> place at line [n] from [filename]
:/pattern/r [filename]  -> place at line after pattern

--- using vim on multiple files
nvim [file1] [file2]
:n                    -> next file
:args                 -> show arguments used with nvim [args...] (current)
:rew                  -> go to first file in :args list
:e [file]             -> pull in new file
:e %[or]#             -> pull in current file or other file
:e!                   -> discard edits and return to last saved version of current file

can also use % as:
:w %.new                 -> save to [current-file-name].new (includes extension though)

------------ LOCAL REPLACEMENT
:s/old/new/               -> replace on current line
:s/old/new/g              -> replace all occurrences on current line
:50,100s/old/new/g        -> replace all occurences on lines 50-100
:1,$s/old/new/g           -> whole file
:%s/old/new/g             -> whole file

:1,30s/old/new/gc         -> also "confirm" all changes automatically
if not using 'c' then each match is prompted:
  (y/n/a/q/l/^E/^Y)
  y   -> substitute
  n   -> skip
  a   -> substitute this match and remaining
  q   -> quit
  l   -> substitute and quit
  ^E  -> scroll screen up
  ^Y  -> scroll screen down
  ESC -> quit

:help s_flags       -> more info

----- Manual find and replace [which] -> [that]
/which
cwthat ESC
n       -> next (repeat search)
n       -> skip one
.       -> repeat change
etc.

---------- GLOBAL REPLACEMENT
:g/[pattern]/ [command]         -> find all lines with [pattern] and perform [command]
:g/# FIXME/d                    -> delete all lines with # FIXME
:g/# FIXME/s/FIXME/DONE/        -> change all FIXME to DONE, add /g to the end to do all instances on the line(s)

if the g and s pattern are the same you can leave it out:
:g/editer/s//editor/g   ==   :%s/editer/editor/g

:g!       -> lines that do NOT contain [pattern]
:v        -> alias of :g!

------- REGULAR EXPRESSIONS
we can use regexp in /args/, e.g:
:%s/\(That\) or \(this\)/\2 or \1/
:s/\(abcd\)\1/alphabet-soup/          -> \1 in /search/ predicate turns abcdabcd = alphabet-soup

use \v at the start of the regex if you want to use |, ?, =, + without escaping them
----- Metacharacters in SEARCH string
.                 -> match any char except newline
*                 -> match zero or more of the previous char
\+                -> match one or more of the previous char
\?                -> match zero or one of previous char
\{n\}             -> match n occurences
\{n,\}            -> match n or more occurences
\{n,m\}           -> match n to m occurences (inclusive)
^                 -> following regexp must be at the start of the line
$                 -> when used at the end, require the regexp to be at the end of the line
[ ]               -> match any character in the brackets, [A-Z], [0-9], [:;A-Za-z()]
[.abc.]           -> treat abc as a unit
(a\|b)            -> match a or b or as a 'global or'
pattern1\|pattern2
/< />             -> match characters at the beginning (\<) or end (\>) of a word
\(.*\)            -> fighting one-eyed kirby: capture the rest of the line to a group
\([0-9]\+\)       -> match and capture any sequence of numbers
\                 -> escape metachar

--- Lookahead assertion with @:
/foo\(bar\)\@=     -> find foo followed by bar
/\vfoo(bar)@=
/foo\(bar\)\@!     -> find food NOT followed by bar
/\vfoo(bar)@!

-- POSIX groups:
[:alnum:] Alphanumeric characters
[:alpha:] Alphabetic characters
[:blank:] Space and tab characters only
[:cntrl:] Control characters
[:digit:] Numeric characters
[:graph:] Printable and visible (nonspace) characters
[:lower:] Lowercase characters
[:print:] Printable characters (includes whitespace)
[:punct:] Punctuation characters
[:space:] All whitespace characters (space, tab, newline, vertical tab, etc.)
[:upper:] Uppercase characters
[:xdigit:] Hexadecimal digits

----- Metacharacters in REPLACEMENT string
\n          -> replace \n with nth group from search
&           -> replace & with the entire text matched
:%s/Washington/&, George/   -> replaces "Washington" with "Washington, George"
\u [or] \l  -> upper/lower case the next char (can be used as e.g \u\n, which only affects first char)
\U [or] \L  -> upper/lower case all chars
\e [or] \E  -> end \U or \L application
\           -> escape metachar

---- Tricks
if you need to find/replace something like a filename with / characters, you can use a different delimeter:
:%s;/user1/tim;/home/time;g     -> ; is the delimeter instead of /

&       -> press to repeat previous substitution

repeat the previous substitution on a different search:
:s/red/blue/
:/green
:~
---> the :~ is equivalent to :s/green/blue

---- Block Moves
:g /[find]/[start],[end] move [location]
example:
:g /<syntax>/.,/<description>/-1 move /<parameter>/-1
where /<description>/ searches for descripion then -1 moves up a line


------ Customizing Vim
:set [option]       -> set [option] to true
:set no[option]     -> set [option] to false
:set [option]!      -> toggle [option]
:set [option]?      -> see current value of [option]
:set all            -> see options in use

------------ Executing UNIX Commands
:![command]         -> run unix [command]
:!pwd/ls etc.
:r !date            -> read in current date
:r !sort [file]     -> sorts [file]

:$r !aspell list < %    -> use UNIX spellcheck on current file, read in at the bottom
                        -> add | sort -u for a sorted list of misspelled words

:96,99!sort         -> sort lines 96-99

------ Abbreviations
:ab [abbr] [phrase]     -> define [abbr] => [phrase] (phrase can't contain abbr)
can also put these in config:
vim.cmd('ab what what')
vim.cmd('ab npc non-player character')

:unab [abbr]            -> delete the [abbr]
:ab                     -> list current abbreviations

------- Mappings
:map [key(s)] [sequence]     -> define [key(s)] as [sequence] of editing commands
--> probably shouldn't use this, have macros anyway...

:map <leader>[key(s)] [sequence]
:let mapleader="X"

:unmap [key(s)]
if you want to use a protected key like Enter, Esc, precede them with Ctrl+V
if you want to use F-12: #1-12
